const xml2js = require('xml2js');

module.exports.name = 'DMXControl 3';
module.exports.version = '0.1.0';

module.exports.import = function importDmxControl3(str, filename, resolve, reject) {

  new xml2js.Parser().parseString(str, (parseError, xml) => {
    if (parseError) {
      return reject(`Error parsing '${filename}' as XML.\n` + parseError.toString());
    }

    let out = {
      manufacturers: {},
      fixtures: {},
      warnings: {}
    };

    try {
      const device = xml.device;
      const info = device.information[0];
      const manName = info.vendor[0];
      const manKey = manName.toLowerCase().replace(/[^a-z0-9\-]+/g, '-');
      out.manufacturers[manKey] = {
        name: manName
      }

      // TODO: check if "modell" is really generated by DDFCreator
      // or if it only was a typo of myself
      const fixName = 'model' in info ? info.model[0] : info.modell[0];
      const fixKey = manKey + '/' + fixName.toLowerCase().replace(/[^a-z0-9\-]+/g, '-');
      out.warnings[fixKey] = [];

      const timestamp = new Date().toISOString().split('T')[0];
      let fix = {
        name: fixName,
        shortName: fixKey,
        categories: [],
        meta: {
          createDate: timestamp,
          lastModifyDate: timestamp,
        },
        availableChannels: {},
        modes: [{
          name: 'Default',
          channels: [],
        }],
      };

      if (info.author) {
        fix.meta.authors = [info.author[0]];
      }

      if (info.mode) {
        fix.modes[0].name = info.mode[0];
      }

      // make sure that channels.length is dmxaddresscount.
      // (undefined channels will later be set to null)
      if (device.$.dmxaddresscount) {
        fix.modes[0].channels[device.$.dmxaddresscount] = null;
      }

      const functions = device.functions[0];
      for (const functionType in functions) {
        for (let i = 0; i < functions[functionType].length; i++) {
          const singleFunction = functions[functionType][i];

          switch(functionType) {
            case 'dimmer':
            case 'colortemp':
            case 'raw':
              let channel = {
                type: 'Intensity',
              }

              const caps = getCapabilities(singleFunction);
              if (caps.length > 0) {
                channel.capabilities = caps;
              }

              if ('defaultval' in singleFunction.$) {
                channel.defaultValue = parseInt(singleFunction.$.defaultval);
              }

              let channelKey;
              if ('name' in singleFunction.$) {
                channelKey = singleFunction.$.name;

                if (functionType == 'raw') {
                  const testName = channelKey.toLowerCase();
                  if (testName.includes('intensity')) {
                    channel.type = 'Intensity';
                  }
                  else if (testName.includes('speed')) {
                    channel.type = 'Speed';
                  }
                  else {
                    out.warnings[fixKey].push(`Please check channel type of '${channelKey}'`);
                  }
                }
              }
              else {
                // "Dimmer" if there's only one dimmer
                // "Dimmer 1", "Dimmer 2", ... if there are more dimmers
                channelKey = capitalize(functionType);
                if (functions[functionType].length > 1) {
                  channelKey += ` ${i+1}`;
                }
              }

              // append " 2", " 3", ... to channel key if it isn't unique
              channelKey = getUniqueChannelKey(channelKey);
              fix.availableChannels[channelKey] = channel;

              addChannelToMode(channelKey, singleFunction.$.dmxchannel, channel);

              if ('finedmxchannel' in singleFunction.$) {
                const fineChannelKey = channelKey + ' fine';
                fix.availableChannels[fineChannelKey] = {
                  type: channel.type,
                };
                addChannelToMode(fineChannelKey, singleFunction.$.finedmxchannel);

                if (fix.multiByteChannels === undefined) {
                  fix.multiByteChannels = [];
                }
                fix.multiByteChannels.push([channelKey, fineChannelKey]);
              }

              warnUnknownAttributes(functionType, singleFunction, ['name', 'defaultval', 'dmxchannel', 'mindmx', 'maxdmx', 'finedmxchannel']);
              warnUnknownChildren(functionType, singleFunction, ['range', 'step']);
              break;

            default:
              // out.warnings[fixKey].push(`Unknown function type ${functionType}`);
          }
        }

        function warnUnknownAttributes(nodeName, node, knownAttributes) {
          if ('$' in node) {
            for (const attr in node.$) {
              if (!knownAttributes.includes(attr)) {
                out.warnings[fixKey].push(`Unknown attribute '${attr}=${node.$[attr]}' in '${nodeName}'`);
              }
            }
          }
        }

        function warnUnknownChildren(nodeName, node, knownChildren) {
          for (const child in node) {
            if (child !== '$' && !knownChildren.includes(child)) {
              out.warnings[fixKey].push(`Unknown child '${child}' in '${nodeName}'`);
            }
          }
        }

        function getCapabilities(node) {
          capabilities = [];

          if ('range' in node) {
            for (const range of node.range) {
              const cap = getCapability(range);
              if (cap != null) {
                capabilities.push(cap);
              }
            }
          }

          if ('step' in node) {
            for (const step of node.step) {
              const cap = getCapability(step);
              if (cap != null) {
                capabilities.push(cap);
              }
            }
          }

          if ('$' in node && 'mindmx' in node.$ && 'maxdmx' in node.$) {
            capabilities.push({
              range: [
                parseInt(node.$.mindmx),
                parseInt(node.$.maxdmx)
              ],
              name: 'Generic'
            });
          }

          capabilities.sort(function(a, b) {
            return a.range[0] - b.range[0];
          });

          return capabilities;
        }

        // node can be step or range
        function getCapability(node) {
          if (typeof node !== 'object') {
            // skip empty <range /> or <step />
            return null;
          }
          else if ('$' in node) {
            let capability = {
              range: [0, 255],
              name: 'Generic'
            };

            capability.range[0] = parseInt(node.$.mindmx);
            capability.range[1] = parseInt(node.$.maxdmx);
            let minval = 'minval' in node.$ ? node.$.minval : '?';
            let maxval = 'maxval' in node.$ ? node.$.maxval : '?';

            if (capability.range[1] < capability.range[0]) {
              [capability.range[0], capability.range[1]] = [capability.range[1], capability.range[0]];
              [minval, maxval] = [maxval, minval];
            }

            if (minval != '?' || maxval != '?') {
              if (minval == maxval) {
                // not a real range
                capability.name = `${minval}`;
              }
              else {
                capability.name = `${minval}-${maxval}`;

                if ('type' in node.$) {
                  capability.name += ` (${node.$.type})`;
                }
              }
            }
            else if ('val' in node.$) {
              capability.name = node.$.val;
            }
            else if ('type' in node.$) {
              capability.name = node.$.type;
            }

            warnUnknownAttributes('range/step', node, ['type', 'mindmx', 'maxdmx', 'minval', 'maxval', 'val'])

            return capability;
          }
        }

        function getUniqueChannelKey(key) {
          if (!(key in fix.availableChannels)) {
            return key;
          }
          let i = 2;
          while (`${key} ${i}` in fix.availableChannels) {
            i++;
          }
          return `${key} ${i}`;
        }

        function addChannelToMode(key, dmxchannel) {
          const existingChannels = fix.modes[0].channels;
          const existingChannel = existingChannels[dmxchannel];
          if (existingChannel !== undefined &&
              existingChannel !== null) {
            out.warnings[fixKey].push(`Attempting to use DMX channel ${dmxchannel} for '${key}' but it is already used by '${existingChannel}'`);
          }
          else {
            existingChannels[dmxchannel] = key;
          }
        }
      }

      for (let i = 0; i < fix.modes[0].channels.length; i++) {
        if (fix.modes[0].channels[i] === undefined) {
          fix.modes[0].channels[i] = null;
        }
      }

      if (fix.categories.length == 0) {
        fix.categories.push('Other');
      }

      out.fixtures[fixKey] = fix;
    }
    catch (parseError) {
      return reject(`Error parsing '${filename}'.\n` + parseError.toString());
    }

    resolve(out);
  });
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}