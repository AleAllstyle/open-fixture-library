const xml2js = require('xml2js');

module.exports.name = 'DMXControl 3';
module.exports.version = '0.1.0';

module.exports.import = function importDmxControl3(str, filename, resolve, reject) {

  new xml2js.Parser().parseString(str, (parseError, xml) => {
    if (parseError) {
      return reject(`Error parsing '${filename}' as XML.\n` + parseError.toString());
    }

    let out = {
      manufacturers: {},
      fixtures: {},
      warnings: {}
    };

    try {
      const device = xml.device;
      const info = device.information[0];
      const manName = info.vendor[0];
      const manKey = manName.toLowerCase().replace(/[^a-z0-9\-]+/g, '-');
      out.manufacturers[manKey] = {
        name: manName
      }

      // TODO: check if "modell" is really generated by DDFCreator
      // or if it only was a typo of myself
      const fixName = 'model' in info ? info.model[0] : info.modell[0];
      const fixKey = manKey + '/' + fixName.toLowerCase().replace(/[^a-z0-9\-]+/g, '-');
      out.warnings[fixKey] = [];

      const timestamp = new Date().toISOString().split('T')[0];
      let fix = {
        name: fixName,
        shortName: fixKey,
        categories: [],
        meta: {
          createDate: timestamp,
          lastModifyDate: timestamp,
        },
        availableChannels: {},
        modes: [{
          name: 'Default',
          channels: [],
        }],
      };

      if (info.author) {
        fix.meta.authors = [info.author[0]];
      }

      if (info.mode) {
        fix.modes[0].name = info.mode[0];
      }

      if (device.$.dmxaddresscount) {
        fix.modes[0].channels[device.$.dmxaddresscount] = undefined;
      }

      const functions = device.functions[0];
      for (const functionType in functions) {
        for (const singleFunction of functions[functionType]) {
          switch(functionType) {
            case 'dimmer':
            case 'colortemp':
              let channel = {
                name: capitalize(functionType),
                type: 'Intensity',
              }

              channel.capabilities = getCapabilities(singleFunction);

              const channelKey = getUniqueChannelKey(functionType);
              fix.availableChannels[channelKey] = channel;
              fix.modes[0].channels[singleFunction.$.dmxchannel] = channelKey;

              if ('finedmxchannel' in singleFunction.$) {
                const fineChannelKey = getUniqueChannelKey(channelKey + '-fine');
                fix.availableChannels[fineChannelKey] = {
                  name: channel.name + ' fine',
                  type: channel.type,
                };
                fix.modes[0].channels[singleFunction.$.finedmxchannel] = fineChannelKey;

                if (fix.multiByteChannels === undefined) {
                  fix.multiByteChannels = [];
                }
                fix.multiByteChannels.push([channelKey, fineChannelKey]);
              }

              warnUnknownAttributes(functionType, singleFunction, ['dmxchannel', 'mindmx', 'maxdmx']);
              break;

            default:
              // out.warnings[fixKey].push(`Unknown function type ${functionType}`);
          }
        }

        function warnUnknownAttributes(nodeName, node, knownAttributes) {
          if ('$' in node) {
            attrs: for (const attr in node.$) {
              for (const knownAttr of knownAttributes) {
                if (attr == knownAttr) {
                  continue attrs;
                }
              }
              out.warnings[fixKey].push(`Unknown attribute ${attr} = ${node.$[attr]} in ${nodeName}`);
            }
          }
        }

        function getCapabilities(node) {
          capabilities = [];

          if ('range' in node) {
            for (const range of node.range) {
              if (typeof range !== 'object') {
                // skip empty <range />
                continue;
              }
              else if ('$' in range) {
                let capability = {
                  range: [0, 255],
                  name: 'Generic'
                };

                capability.range[0] = parseInt(range.$.mindmx);
                capability.range[1] = parseInt(range.$.maxdmx);
                let minval = 'minval' in range.$ ? range.$.minval : '?';
                let maxval = 'maxval' in range.$ ? range.$.maxval : '?';

                if (capability.range[1] < capability.range[0]) {
                  [capability.range[0], capability.range[1]] = [capability.range[1], capability.range[0]];
                  [minval, maxval] = [maxval, minval];
                }

                if (minval != '?' || maxval != '?') {
                  capability.name = `${minval}-${maxval}`;

                  if ('type' in range.$) {
                    capability.name += ` (${range.$.type})`;
                  }
                }
                else if ('type' in range.$) {
                  capability.name = range.$.type;
                }

                warnUnknownAttributes('range', range, ['type', 'mindmx', 'maxdmx', 'minval', 'maxval'])

                capabilities.push(capability);
              }
            }
          }

          if ('$' in node && 'mindmx' in node.$ && 'maxdmx' in node.$) {
            capabilities.push({
              range: [
                parseInt(node.$.mindmx),
                parseInt(node.$.maxdmx)
              ],
              name: 'Generic'
            });
          }

          return capabilities;
        }

        function getUniqueChannelKey(key) {
          if (!(key in fix.availableChannels)) {
            return key;
          }
          let i = 2;
          while (`${key}-${i}` in fix.availableChannels) {
            i++;
          }
          return `${key}-${i}`;
        }
      }

      for (let i = 0; i < fix.modes[0].channels.length; i++) {
        if (fix.modes[0].channels[i] === undefined) {
          fix.modes[0].channels[i] = null;
        }
      }

      if (fix.categories.length == 0) {
        fix.categories.push('Other');
      }

      out.fixtures[fixKey] = fix;
    }
    catch (parseError) {
      return reject(`Error parsing '${filename}'.\n` + parseError.toString());
    }

    resolve(out);
  });
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}