const xml2js = require('xml2js');

module.exports.name = 'DMXControl 3';
module.exports.version = '0.1.0';

module.exports.import = function importDmxControl3(str, filename, resolve, reject) {

  new xml2js.Parser().parseString(str, (parseError, xml) => {
    if (parseError) {
      return reject(`Error parsing '${filename}' as XML.\n` + parseError.toString());
    }

    let out = {
      manufacturers: {},
      fixtures: {},
      warnings: {}
    };

    try {
      const device = xml.device;
      const info = device.information[0];
      const manName = info.vendor[0];
      const manKey = manName.toLowerCase().replace(/[^a-z0-9\-]+/g, '-');
      out.manufacturers[manKey] = {
        name: manName
      }

      // TODO: check if "modell" is really generated by DDFCreator
      // or if it only was a typo of myself
      const fixName = 'model' in info ? info.model[0] : info.modell[0];
      const fixKey = manKey + '/' + fixName.toLowerCase().replace(/[^a-z0-9\-]+/g, '-');
      out.warnings[fixKey] = [];

      const timestamp = new Date().toISOString().split('T')[0];
      let fix = {
        name: fixName,
        shortName: fixKey,
        categories: [],
        meta: {
          createDate: timestamp,
          lastModifyDate: timestamp,
        },
        availableChannels: {},
        modes: [{
          name: 'Default',
          channels: [],
        }],
      };

      if (info.author) {
        fix.meta.authors = [info.author[0]];
      }

      if (info.mode) {
        fix.modes[0].name = info.mode[0];
      }

      // make sure that channels.length is dmxaddresscount.
      // (undefined channels will later be set to null)
      if (device.$.dmxaddresscount) {
        fix.modes[0].channels[device.$.dmxaddresscount] = null;
      }

      const functions = device.functions[0];
      for (const functionType in functions) {
        for (let i = 0; i < functions[functionType].length; i++) {
          const singleFunction = functions[functionType][i]

          switch(functionType) {
            case 'dimmer':
            case 'colortemp':
            case 'raw':
              let channel = {
                type: 'Intensity',
              }

              const caps = getCapabilities(singleFunction);
              if (caps.length > 0) {
                channel.capabilities = caps;
              }

              let channelKey;
              if ('name' in singleFunction.$) {
                channelKey = singleFunction.$.name;
              }
              else {
                // "Dimmer" if there's only one dimmer
                // "Dimmer 1", "Dimmer 2", ... if there are more dimmers
                channelKey = capitalize(functionType);
                if (functions[functionType].length > 1) {
                  channelKey += ` ${i+1}`;
                }
              }

              // append " 2", " 3", ... to channel key if it isn't unique
              channelKey = getUniqueChannelKey(channelKey);
              fix.availableChannels[channelKey] = channel;

              addChannelToMode(channelKey, singleFunction.$.dmxchannel, channel);

              if ('finedmxchannel' in singleFunction.$) {
                const fineChannelKey = channelKey + ' fine';
                fix.availableChannels[fineChannelKey] = {
                  type: channel.type,
                };
                addChannelToMode(finedmxchannel, singleFunction.$.finedmxchannel);

                if (fix.multiByteChannels === undefined) {
                  fix.multiByteChannels = [];
                }
                fix.multiByteChannels.push([channelKey, fineChannelKey]);
              }

              warnUnknownAttributes(functionType, singleFunction, ['name', 'dmxchannel', 'mindmx', 'maxdmx', 'finedmxchannel']);
              warnUnknownChildren(functionType, singleFunction, ['range']);
              break;

            default:
              // out.warnings[fixKey].push(`Unknown function type ${functionType}`);
          }
        }

        function warnUnknownAttributes(nodeName, node, knownAttributes) {
          if ('$' in node) {
            attrs: for (const attr in node.$) {
              for (const knownAttr of knownAttributes) {
                if (attr == knownAttr) {
                  continue attrs;
                }
              }
              out.warnings[fixKey].push(`Unknown attribute '${attr}=${node.$[attr]}' in '${nodeName}'`);
            }
          }
        }

        function warnUnknownChildren(nodeName, node, knownAttributes) {
          children: for (const child in node) {
            if (child === '$') {
              continue children;
            }
            for (const knownAttr of knownAttributes) {
              if (child == knownAttr) {
                continue children;
              }
            }
            out.warnings[fixKey].push(`Unknown child '${child}' in '${nodeName}'`);
          }
        }

        function getCapabilities(node) {
          capabilities = [];

          if ('range' in node) {
            for (const range of node.range) {
              if (typeof range !== 'object') {
                // skip empty <range />
                continue;
              }
              else if ('$' in range) {
                let capability = {
                  range: [0, 255],
                  name: 'Generic'
                };

                capability.range[0] = parseInt(range.$.mindmx);
                capability.range[1] = parseInt(range.$.maxdmx);
                let minval = 'minval' in range.$ ? range.$.minval : '?';
                let maxval = 'maxval' in range.$ ? range.$.maxval : '?';

                if (capability.range[1] < capability.range[0]) {
                  [capability.range[0], capability.range[1]] = [capability.range[1], capability.range[0]];
                  [minval, maxval] = [maxval, minval];
                }

                if (minval != '?' || maxval != '?') {
                  if (minval == maxval) {
                    // not a real range
                    capability.name = `${minval}`;
                  }
                  else {
                    capability.name = `${minval}-${maxval}`;

                    if ('type' in range.$) {
                      capability.name += ` (${range.$.type})`;
                    }
                  }
                }
                else if ('type' in range.$) {
                  capability.name = range.$.type;
                }

                warnUnknownAttributes('range', range, ['type', 'mindmx', 'maxdmx', 'minval', 'maxval'])

                capabilities.push(capability);
              }
            }
          }

          if ('$' in node && 'mindmx' in node.$ && 'maxdmx' in node.$) {
            capabilities.push({
              range: [
                parseInt(node.$.mindmx),
                parseInt(node.$.maxdmx)
              ],
              name: 'Generic'
            });
          }

          capabilities.sort(function(a, b) {
            return a.range[0] - b.range[0];
          });

          return capabilities;
        }

        function getUniqueChannelKey(key) {
          if (!(key in fix.availableChannels)) {
            return key;
          }
          let i = 2;
          while (`${key} ${i}` in fix.availableChannels) {
            i++;
          }
          return `${key} ${i}`;
        }

        function addChannelToMode(key, dmxchannel) {
          const existingChannels = fix.modes[0].channels;
          const existingChannel = existingChannels[dmxchannel];
          if (existingChannel !== undefined &&
              existingChannel !== null) {
            out.warnings[fixKey].push(`Attempting to use DMX channel ${dmxchannel} for '${key}' but it is already used by '${existingChannel}'`);
          }
          else {
            existingChannels[dmxchannel] = key;
          }
        }
      }

      for (let i = 0; i < fix.modes[0].channels.length; i++) {
        if (fix.modes[0].channels[i] === undefined) {
          fix.modes[0].channels[i] = null;
        }
      }

      if (fix.categories.length == 0) {
        fix.categories.push('Other');
      }

      out.fixtures[fixKey] = fix;
    }
    catch (parseError) {
      return reject(`Error parsing '${filename}'.\n` + parseError.toString());
    }

    resolve(out);
  });
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}